<!DOCTYPE html>
<html>
  <head>
    <title>Course 5 - Renode</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../style/style.css"></link>
    <style>
      
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Tock Drivers API

.title[.center[![SecureEmbeddedProgramming](../images/sep.png)]]

.left[
Alexandru Radovici, Cosmin Daniel Radu, ilustrations by [Mieuneli](http://miau.laura.ro)
]

---

# Overview

1. Simple Driver 
2. System calls
3. Grants

---

# Tock Running Environment

You will have to download:
- [Renode](https://github.com/renode/renode/releases/tag/v1.11.0) - select renode-1.11.0.linux-portable.tar.gz
 for linux then unpack the archive using:

```bash
wget https://github.com/renode/renode/releases/download/v1.11.0/renode-1.11.0.linux-portable.tar.gz

tar xvf renode-1.11.0.linux-portable.tar.gz
 ```

- [Tock Virtual Machine](https://ctipub-my.sharepoint.com/:u:/g/personal/alexandru_radovici_upb_ro/EZfcjTnz199Jjk5LzAxmCkABJrZR86VLnzfqLhb2Gby3LA?e=6O3Mw0) - Import Appliance
    - Windows: Make sure you select __Allow__ when you get a question from the Firewall

---
# Tock Running Environment

To connect and use Renode, please access virtualbox and forward the telnet port

.center[.title[![Remote SHH Link](../images/network_settings.png)]]

---
# Tock Running Environment

.center[.title[![Remote SHH Link](../images/port_forwarding_rule.png)]]

---
# Building an application

Go to the directory of examples from libtock-c.

Go to the c_hello app then run the make command.

```bash
make
```

.center[.title[![Remote SHH Link](../images/build_app.png)]]

---
# Compile the kernel with the app

Change the branch of the tock repository

```bash
git checkout saiot
```

.center[.title[![Remote SHH Link](../images/change_branch.png)]]

---
# Compile the kernel with the app

Go to the directory of the stm32f4 and add the following lines under include in the Makefile.

```bash
APP=../../../libtock-c/examples/blink/build/cortex-m4/cortex-m4.tbf
KERNEL=$(TOCK_ROOT_DIRECTORY)/target/$(TARGET)/debug/$(PLATFORM).elf
KERNEL_WITH_APP=$(TOCK_ROOT_DIRECTORY)/target/$(TARGET)/debug/$(PLATFORM)-app.elf
```

And replace .PHONY: program with those lines

```bash
.PHONY: program
program: $(TOCK_ROOT_DIRECTORY)target/$(TARGET)/debug/$(PLATFORM).elf
	arm-none-eabi-objcopy --update-section .apps=$(APP) $(KERNEL) $(KERNEL_WITH_APP)
```
Now run the make program command.

```bash
make program
```


---

# Setting up the application binary for Renode

After unpacking go to /renode_1.11.0_portable/scripts/single-node and open with a text editor "stm32f4_discovery.resc"

Replace the path with the path to the binary of the kernel built with the application.

Old:

```bash
$bin?=@https://dl.antmicro.com/projects/renode/stm32f4discovery.elf-s_445441-827a0dedd3790f4559d7518320006613768b5e72
```

New (this is an example, please update the path to yours):

```bash
$bin?=@~/git/tock2/tock/target/thumbv7em-none-eabi/debug/stm32f4discovery-app.elf
```
---

# Setting up the application binary for Renode

Replace the following line:

Old:

```bash
showAnalyzer sysbus.uart4
```

New:
```bash
showAnalyzer sysbus.uart2
```

.center[.title[![Remote SHH Link](../images/renode_script.png)]]

---

# Running the application

Connect via ssh to the tock virtual machine

```bash
ssh localhost:2000
```

Go to renode-1.11.0.linux-portable and run renode

```bash
./renode
```

---

# Running the application

Open a new connection to the localhost:1234 using telnet and then use the following command to start your application.

```bash
s @scripts/single-node/stm32f4_discovery.resc
```

.center[.title[![Remote SHH Link](../images/renode_command.png)]]

---
# Workpoint 1 .top_image[![Work In Progress](../images/work_in_progress.png)]

Enable the system calls trace in `kernel/src/config.rs`. 
1. Upload and app that prints a text on the shell using `printf`. 
  - How many system calls is printf using?
  - What is the driver number of the driver used for printing?

2. Upload the blink app and look at the system calls trace.
  - What is led's driver number?

---
# Hello Driver

Kernel

1. Write the `Hello` and its implementation
2. Implement the `Driver` trait for `Hello`
  - all methiods have default implementation
3. Add the driver to the board structure in `main.rs`

User space

- Implement the system calls

---
## Kernel

Write the driver and implement the `Driver` trait (1 and 2).

Write a file `hello.rs` in the same folder as `main.rs`.

```rust
use kernel::{Driver, AppId, ReturnCode};

/// Each driver is identified by a unique number
///
/// numbers higher than 0xa0000000 are unused by standard drivers
pub const DRIVER_NUM: usize = 0xa0000000;

/// The Hello structure
pub struct Hello {}


/// The hello implementation
impl Hello {
    pub fn new() -> Hello {
        Hello {}
    }
}

/// The driver system calls implementation
impl Driver for Hello {
    /// subscribe and allow will use the default implementation

    /// command syscall
    fn command(&self, command_num: usize, _data1: usize, _data2: usize, _app_id: AppId) -> ReturnCode {
        match command_num {
            // command_num 0 is used to verify if the driver exists
            0 => ReturnCode::SUCCESS,

            // the command number is not defined
            _ => ReturnCode::ENOSUPPORT,
        }
    }
}
```

---
## Kernel

Register the driver for in the board's structure (3)

In `main.rs` 

```rust
/// use the driver module
mod hello;

// ...

/// A structure representing this platform that holds references to all
/// capsules for this platform.
struct STM32F412GDiscovery {
    console: &'static capsules::console::Console<'static>,
    ipc: kernel::ipc::IPC,
    led: &'static capsules::led::LED<'static, stm32f412g::gpio::Pin<'static>>,
    button: &'static capsules::button::Button<'static, stm32f412g::gpio::Pin<'static>>,
    alarm: &'static capsules::alarm::AlarmDriver<
        'static,
        VirtualMuxAlarm<'static, stm32f412g::tim2::Tim2<'static>>,
    >,
    gpio: &'static capsules::gpio::GPIO<'static, stm32f412g::gpio::Pin<'static>>,
    adc: &'static capsules::adc::Adc<'static, stm32f412g::adc::Adc>,
    ft6x06: &'static capsules::ft6x06::Ft6x06<'static>,
    touch: &'static capsules::touch::Touch<'static>,
    // hello driver
    hello: &'static hello::Hello
}

// ...

/// Mapping of integer syscalls to objects that implement syscalls.
impl Platform for STM32F412GDiscovery {
    fn with_driver<F, R>(&self, driver_num: usize, f: F) -> R
    where
        F: FnOnce(Option<&dyn kernel::Driver>) -> R,
    {
        match driver_num {
            capsules::console::DRIVER_NUM => f(Some(self.console)),
            capsules::led::DRIVER_NUM => f(Some(self.led)),
            capsules::button::DRIVER_NUM => f(Some(self.button)),
            capsules::alarm::DRIVER_NUM => f(Some(self.alarm)),
            kernel::ipc::DRIVER_NUM => f(Some(&self.ipc)),
            capsules::gpio::DRIVER_NUM => f(Some(self.gpio)),
            capsules::adc::DRIVER_NUM => f(Some(self.adc)),
            capsules::ft6x06::DRIVER_NUM => f(Some(self.ft6x06)),
            capsules::touch::DRIVER_NUM => f(Some(self.touch)),
            // hello driver
            hello::DRIVER_NUM => f(Some(self.hello)),
            _ => f(None),
        }
    }
}

// ...

/// Reset Handler.
///
/// This symbol is loaded into vector table by the STM32F446RE chip crate.
/// When the chip first powers on or later does a hard reset, after the core
/// initializes all the hardware, the address of this function is loaded and
/// execution begins here.
#[no_mangle]
pub unsafe fn reset_handler() {
    // ...

    /// Create a new instance of type Hello using Hello::new ()
    let hello = static_init! (hello::Hello, hello::Hello::new());

    /// Create a new instance of the board's structure
    let stm32f412g = STM32F412GDiscovery {
        console: console,
        ipc: kernel::ipc::IPC::new(board_kernel, &memory_allocation_capability),
        led: led,
        button: button,
        alarm: alarm,
        gpio: gpio,
        adc: adc,
        ft6x06: ft6x06,
        touch: touch,
        // the hello driver
        hello: hello,
    };

    // ...
}
```

---
## User space

In your application's folder

hello.h
```c
#pargma once

#define HELLO_DRIVER_NUMBER 0xa0000000

bool hello_is_available (void);

```

hello.c
```c
#include "hello.h"
#include <tock.h>

bool hello_is_available (void) {
    if (command (HELLO_DRIVER_NUMBER, 0, 0, 0) == TOCK_SUCCESS) {
        return true;
    } else {
        return false;
    }
}
```

---
## Workpoint 2 .top_image[![Work In Progress](../images/work_in_progress.png)]

Add `command_num` 1 to the driver and print a text on the shell when it is called.

```rust
/// The driver system calls implementation
impl Driver for Hello {
    /// subscribe and allow will use the default implementation

    /// command syscall
    fn command(&self, command_num: usize, _data1: usize, _data2: usize, _app_id: AppId) -> ReturnCode {
        match command_num {
            // command_num 0 is used to verify if the driver exists
            0 => ReturnCode::SUCCESS,
            1 => // ...

            // the command number is not defined
            _ => ReturnCode::ENOSUPPORT,
        }
    }
}
```

Add a function for it in the header and source file in userspace. 
Write and upload an app that userspac the driver.

---
# Mutability

All Tock traits use `&self` to be able to share a driver with several other drivers.

Interior mutability:
- Cell<T> (`core::cell::Cell`)
- OptionalCell<T> (`kernel::common:cells::OptionalCell`)
- TakeCell<T> (`kernel::common::cells::TakeCell`)

.right[
.card[.small_vertical[![Cell](../images/sep_cell.png)]]
.card[.small_vertical[![OptionalCell](../images/sep_optionalcell.png)]]
.card[.small_vertical[![TakeCell](../images/sep_takecell.png)]]
]

---

## Cell

Store a mutable value inside a immutable structure

```rust
use kernel::{Driver, AppId, ReturnCode};
use core::cell::Cell;

/// Each driver is identified by a unique number
///
/// numbers higher than 0xa0000000 are unused by standard drivers
pub const DRIVER_NUM: usize = 0xa0000000;

/// The Hello structure
pub struct Hello {
    nr: Cell<usize>
}


/// The hello implementation
impl Hello {
    pub fn new() -> Hello {
        Hello {
            nr: Cell::new (0)
        }
    }
}

/// The driver system calls implementation
impl Driver for Hello {
    /// subscribe and allow will use the default implementation

    /// command syscall
    fn command(&self, command_num: usize, _data1: usize, _data2: usize, _app_id: AppId) -> ReturnCode {
        match command_num {
            // command_num 0 is used to verify if the driver exists
            0 => ReturnCode::SUCCESS,

            2 => {
                // modify number
                self.nr.set (self.nr.get () + 1);
                ReturnCode::SuccessWithValue { value: self.nr.get() }
            }

            // the command number is not defined
            _ => ReturnCode::ENOSUPPORT,
        }
    }
}
```

---
## Workpoint 3 .top_image[![Work In Progress](../images/work_in_progress.png)]

Add `command_num` 2 that will increment a counter and return it to the app.
  Hint: use `ReturnCode::SuccessWithValue { value: ... }`

Each time the app calls the system call, the driver will will return an incremented number.

```c
#include "hello.c"
#include <stdio.h>
#include <timer.h>

int nr;

int main(void) {
    while (true) {
        nr = hello_counter ();
        printf ("Counter %d\n", n);
        delay_ms (1000);
    }
}
```

Hint: store the current number in the `Hello` structure.

---
# Grants

- Drivers may not allocate memeory
- Drivers store data for every app
- Data is deallocated when the app stops

.card[.large[.center[![Borrow Rules](../images/sep_process_memory.png)]]]

---

## Grants Usage

In `hello.rs`
```rust
#[derive(Default)]
pub struct AppData {
    // ...
}

pub struct Hello {
    // ...
    grant: Grant<AppData>
}
```

In `main.rs`
```rust
#[no_mangle]
pub unsafe fn reset_handler() {
    // ...
    let grant_cap = create_capability!(capabilities::MemoryAllocationCapability);
    let grant_hello = board_kernel.create_grant(&grant_cap);

    let hello = static_init!(
        hello::Hello,
        hello::Hello::new(grant_hello)
    );
    // ...
}
```
---

## Using the Grant

```rust
impl Driver for Hello {
    fn command(
        &self,
        command_num: usize,
        _data1: usize,
        _data2: usize,
        app_id: AppId,
    ) -> ReturnCode {
        match command_num {
            0 => ReturnCode::SUCCESS,
            1 => {
                self.grant.enter (app_id, |app, _| {
                    // app is of type AppData
                    // use app. ...
                    ReturnCode::SUCCESS
                }).unwrap_or_else (|err| err.into())
            }
            _ => ReturnCode::ENOSUPPORT,
        }
    }
}
```

---
# Loading multiple apps

The easiest way is to concatenate the tbf files

```bash
cat app1.tbf app2.tbf > app.data
```

Use the `dat` file instead of the `tbf` file.

---

# Workpoint 4 .top_image[![Work In Progress](../images/work_in_progress.png)]

Load the `hello` and the `blink` apps.

---

# Workpoint 5 .top_image[![Work In Progress](../images/work_in_progress.png)]

Modify the counter driver to use a different counter for each app. Load two apps that print the counter at different intervals.

```rust
impl Driver for Hello {
    /// subscribe and allow will use the default implementation
    /// command syscall
    fn command(&self, command_num: usize, _data1: usize, _data2: usize, _app_id: AppId) -> ReturnCode {
        match command_num {
            // command_num 0 is used to verify if the driver exists
            0 => ReturnCode::SUCCESS,
            1 => { debug! ("Print Hello"); ReturnCode::SUCCESS }
            2 => {
                // use a grant
                self.nr.set (self.nr.get () + 1);
                ReturnCode::SuccessWithValue { value: self.nr.get() }
            }
            // the command number is not defined
            _ => ReturnCode::ENOSUPPORT,
        }
    }
}
```




    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script src="../script/playground.js">
    </script>
    <script>
      var slideshow = remark.create({
		navigation: {
				scroll: false
			}
    });
    window.cPlaygroundUrl = "https://cplayground.com/";
    window.playgroundUrl = "https://play.rust-lang.org/";
    </script>
  </body>
</html>